# JavaScriptCore

## RefCountedBase

This base class holds the non-template methods and attributes.
The RefCounted class inherits from it reducing the template bloat
generated by the compiler (technique called template hoisting).

## RefCounted < RefCountedBase, Noncopyable

## Noncopyable

We don't want argument-dependent lookup to pull in everything from the WTF
namespace when you use Noncopyable, so put it in its own namespace.

## SourceCode

## Lexer

Lexer converts SourceCode into a sequence of tokens.

Lexer::lex returns a int.

	#0	0x004d8d76 in JSC::Lexer::lex at Lexer.cpp:280
	#1	0x004da6ab in jscyylex at Lexer.cpp:52
	#2	0x004daa51 in jscyyparse at Grammar.cpp:2927
	#3	0x004e84c6 in JSC::Parser::parse at Parser.cpp:58
	#4	0x005460e1 in JSC::Parser::parse<JSC::ProgramNode> at Parser.h:69
	#5	0x004e90c4 in JSC::evaluate at Completion.cpp:59
	#6	0x006aa1f0 in JSC::Interpreter::execute at Interpreter.cpp:591
	#7	0x00638225 in JSC::evaluate at Completion.cpp:67
	#8	0x03d9b5eb in WebCore::ScriptController::evaluate at ScriptController.cpp:114
	#9	0x038d1707 in WebCore::FrameLoader::executeScript at FrameLoader.cpp:766
	#10	0x039a0f2e in WebCore::HTMLTokenizer::scriptExecution at HTMLTokenizer.cpp:561
	#11	0x039a28e7 in WebCore::HTMLTokenizer::scriptHandler at HTMLTokenizer.cpp:503
	#12	0x039a2f99 in WebCore::HTMLTokenizer::parseNonHTMLText at HTMLTokenizer.cpp:350
	#13	0x039a549c in WebCore::HTMLTokenizer::parseTag at HTMLTokenizer.cpp:1520
	#14	0x039a5f2c in WebCore::HTMLTokenizer::write at HTMLTokenizer.cpp:1748
	...
	

## Parser

	var a = 1;
	var b = 2;
	alert(a + b);

is turned into

	- ProgramNode
	  - VarStatementNode => "var"
	    - AssignResolveNode => "a ="
	      - NumberNode => "1"
	  - VarStatementNode => "var"
	    - AssignResolveNode => "b ="
	      - NumberNode => "2"
	  - ExprStatementNode
	    - FunctionCallResolveNode => "alert"
	      - ArgumentsNode => "(" ")"
	        - ArgumentListNode
	          - AddNode => "+"
	            - ResolveNode => "a"
	            - ResolveNode => "b"

## Node

	int m_line;

Node::emitBytecode works by recursively calling emitBytecode for each of the child nodes and receiving the register id where the result is stored. It will then generate the bytecode for itself. BytecodeGenerator will be used to generate the bytecode. It keeps track of all the registries. 

	/*
	    Return value: The register holding the production's value.
		   dst: An optional parameter specifying the most efficient
		        destination at which to store the production's value.
		        The callee must honor dst.

	    dst provides for a crude form of copy propagation. For example,

	    x = 1

	    becomes
    
	    load r[x], 1
    
	    instead of 

	    load r0, 1
	    mov r[x], r0
    
	    because the assignment node, "x =", passes r[x] as dst to the number
	    node, "1".
	*/
	virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* dst = 0) = 0;

![Node class hierarchy](nodeclasshierarchy.png)

## ProgramNode < ScopeNode

## ScopeNode < StatementNode

Node with scope.

	class ScopeNode : public StatementNode, public ParserArenaRefCounted {
		...
	private:
        OwnPtr<ScopeNodeData> m_data;
        CodeFeatures m_features;
        SourceCode m_source;
    };

ScopeNodeData

	struct ScopeNodeData {
        typedef DeclarationStacks::VarStack VarStack;
        typedef DeclarationStacks::FunctionStack FunctionStack;

        ScopeNodeData(ParserArena&, SourceElements*, VarStack*, FunctionStack*, int numConstants);

        ParserArena m_arena;
        VarStack m_varStack;
        FunctionStack m_functionStack;
        int m_numConstants;
        StatementVector m_children;

        void mark();
    };

## EvalNode < ScopeNode

## FunctionBodyNode < ScopeNode

## StatementNode < Node

## AddNode < BinaryOpNode

## BinaryOpNode < ExpressionNode

## ArgumentsNode < ParserArenaDeletable

## BytecodeGenerator

	// The emitNode functions are just syntactic sugar for calling
	// Node::emitCode. These functions accept a 0 for the register,
	// meaning that the node should allocate a register, or ignoredResult(),
	// meaning that the node need not put the result in a register.
	// Other emit functions do not accept 0 or ignoredResult().
	RegisterID* emitNode(RegisterID* dst, Node* n)
	{
		...
	}

## Identifier

These identifiers are stored in the identifierTable on the globalData.  The identifiers are represented by objects of type Identifier.  If you look in parse.h, the nodes that have an identifier as a one of their properties typically have a field called m_ident.  Within the Identifer constructor it calls Identifer::add() (which is in Identifier.cpp), and this ensures each identifier is represented by a unique string in the identifierTable.

## Completion

## Interpreter

Renamed from Machine. 

## CallFrame

typedef ExecState CallFrame;

## ExecState < Register

Represents the current state of script execution. Passed as the first argument to most functions.

## RegisterFile

A register file is a stack of register frames. 

## JSLock

To make it safe to use JavaScript on multiple threads, it is
important to lock before doing anything that allocates a
JavaScript data structure or that interacts with shared state
such as the protect count hash table. The simplest way to lock
is to create a local JSLock object in the scope where the lock 
must be held. The lock is recursive so nesting is ok. The JSLock 
object also acts as a convenience short-hand for running important
initialization routines.

To avoid deadlock, sometimes it is necessary to temporarily
release the lock. Since it is recursive you actually have to
release all locks held by your thread. This is safe to do if
you are executing code that doesn't require the lock, and you
reacquire the right number of locks at the end. You can do this
by constructing a locally scoped JSLock::DropAllLocks object. The 
DropAllLocks object takes care to release the JSLock only if your
thread acquired it to begin with.

For contexts other than the single shared one, implicit locking is not done,
but we still need to perform all the counting in order to keep debug
assertions working, so that clients that use the shared context don't break.

## Structure

Renamed from StructureID in Changeset 38440. For Polymorphic Inline Cache. Here is the [classic Self paper that describes the original technique](http://research.sun.com/self/papers/pics.html). 

One of our most exciting new optimizations in SquirrelFish Extreme is a polymorphic inline cache. This is an old technique originally developed for the Self language, which other JavaScript engines have used to good effect.

Here is the basic idea: JavaScript is an incredibly dynamic language by design. But in most programs, many objects are actually used in a way that resembles more structured object-oriented classes. For example, many JavaScript libraries are designed to use objects with “x” and “y” properties, and only those properties, to represent points. We can use this knowledge to optimize the case where many objects have the same underlying structure - as people in the dynamic language community say, “you can cheat as long as you don’t get caught”.

So how exactly do we cheat? We detect when objects actually have the same underlying structure — the same properties in the same order — and associate them with a structure identifier, or StructureID. Whenever a property access is performed, we do the usual hash lookup (using our highly optimized hashtables) the first time, and record the StructureID and the offset where the property was found. Subsequent times, we check for a match on the StructureID - usually the same piece of code will be working on objects of the same structure. If we get a hit, we can use the cached offset to perform the lookup in only a few machine instructions, which is much faster than hashing.

StructureTransitionTable, a HashMap, stores the structure transitions.

## JSImmediate

JSValue* can be a JSCell* or JSImmediate. You have to tell them apart with low 2 bits of the pointer. 

	if (low 2 bits == 0x00)
	    this is a JSCell*
	else
	    this is a JSImmediate
	    if (low 1 bits == 0x1)
	       this is a JSImmediate 31 bit Integer
	    else
	        // low 2 bits == 0x10
	        switch (low 4 bits)
				case 0x0110:
					this is a JSImmediate Boolean
				case 0x1010:
					this is a JSImmediate Undefined
				case 0x0010:
					this is a JSImmediate Null

JSValue::put takes a PropertySlot& argument, so it can fill in details
about where it put a value, for the sake of caching.

Nitro Extreme changes this to use 64 bit pointers. Doubles can be represented as an atomic value.

## JSCell

	Structure * m_structure

JSCell is a small memory block, which is maintaned by the garbage
collector. It is 32 bit on 32 bit machines and 64 byte in 64 bit machines
(see JavaScriptCore/runtime/collector.cpp).

JSValuePtr is the basic data type structure of JavaScript. It can be a
pointer to a JSCell or an immediate value (integer number, boolean, null,
undefined).

JSCell is an internal representation (may changed in the future), while
JSValuePtr is a high-level class with many helper/utility functions.

JSValuePtr has a toString method. It is a high level function, not
designed for debug purposes, but you can use it if the conversion does not
throw any exceptions.

JSCells now have a StructureID that uniquely identifies their layout,
and holds their prototype.

![JSCell class hierarchy](jscellhierarchy.png)

## JSObject < JSCell

Properties of a JSObject has several types, defined in the ECMA spec.

    // ECMA 262-3 8.6.1
    // Property attributes
    enum Attribute {
        None         = 0,
        ReadOnly     = 1 << 1,  // property can be only read, not written
        DontEnum     = 1 << 2,  // property doesn't appear in (for .. in ..)
        DontDelete   = 1 << 3,  // property can't be deleted
        Function     = 1 << 4,  // property is a function - only used by static hashtables
        Getter       = 1 << 5,  // property is a getter
        Setter       = 1 << 6   // property is a setter
    };

JSObject::get gets the property value. JSObject::put sets the property value. 

How put works.

    void JSObject::put(ExecState* exec, const Identifier& propertyName, JSValue value, PutPropertySlot& slot)
    {
        ...
        if (propertyName == exec->propertyNames().underscoreProto) {
            // Setting __proto__ to a non-object, non-null value is silently ignored to match Mozilla.
            ...
            return;
        }

        // Check if there are any setters or getters in the prototype chain
        JSValue prototype;
        for (JSObject* obj = this; !obj->structure()->hasGetterSetterProperties(); obj = asObject(prototype)) {
            ...
        }
        ...
        for (JSObject* obj = this; ; obj = asObject(prototype)) {
            ...
        }
        // Found no setter so set the property normally
        putDirectInternal(exec->globalData(), propertyName, value, 0, true, slot);
        return;
    }
    
How JSObject::putDirectInternal works.

    inline void JSObject::putDirectInternal(const Identifier& propertyName, JSValue value, unsigned attributes, bool checkReadOnly, PutPropertySlot& slot, JSCell* specificFunction)
    {
        ...
        if (m_structure->isDictionary()) {
            unsigned currentAttributes;
            JSCell* currentSpecificFunction;
            size_t offset = m_structure->get(propertyName, currentAttributes, currentSpecificFunction);
            
            // If property is in the existing Structure, use fast case with putDirectOffset #UNCONFIRMED
            if (offset != WTF::notFound) {
                ...
                putDirectOffset(offset, value);
                ...
            }

            // ???
        }

        // ???
        
        // ???
        
        // Transition to a new Structure and set the property @UNCONFIRMED
    }

@TODO How are the properties stored?

	class JSObject : public JSCell {
	    ...
        RefPtr<Structure> m_inheritorID;

        union {
	  PropertyStorage m_externalStorage;
	  EncodedJSValue m_inlineStorage[inlineStorageCapacity];
        };
	}

## JSString < JSCell

	UString m_value

## SmallStrings

Empty strings or 1 character strings are stored in GlobalData and managed by SmallStrings. For inline caching. @UNCONFIRMED

## StringObject < JSWrapperObject

	m_internalValue is set to a JSString*

## JSWrapperObject < JSObject

This class is used as a base for classes such as String, Number, Boolean and Date which are wrappers for primitive types.

	JSValue m_internalValue;

## Bytecodes

Use JavaScriptCore/docs/make-bytecode-docs.pl to generate up-to-date documentation.

## CallType

    enum CallType {
        CallTypeNone,
        CallTypeHost,   // Native Function
        CallTypeJS      // JS Function
    };

## Layered Architecture

[Original Document](https://bugs.webkit.org/show_bug.cgi?id=24986#c43)

I've not done a good job anywhere of trying to describe the layers in the
architecture, so let me do a better job now.  The abstract code generation
layer (MacroAssembler interface down) is layered like a traditional compiler. 
In a traditional compiler, it is common to have an assembler layer completely
independent of the compiler (often a separate application).  The compiler takes
a source code file, compiles it, and produces an output file of assembly code. 
The interface to the assembler is largely made up of a set of assembly code
mnemonics from which there is typically a one-to-one mapping to machine
instructions (additionally there are assembler directives).

Let's look at an example:

arith.c: (compiled will gcc 4.0 -O3 -march=armv6)

     int sub(int x)
    {
        return x - 12345678;
    }

     int mul(int x)
    {
         return x * 12345678;
    }

arith.s:  (With some .globl & .align directives stripped out to make it more
readable.)

    _sub:
        sub    r0, r0, #12320768
        sub    r0, r0, #24832
        sub    r0, r0, #78
        bx    lr

    _mul:
        ldr    r3, L5
        mul    r0, r0, r3
        bx    lr

    L5:
        .long    12345678

In the case of the subtract, since the immediate does not fit within an
immediate field of a subtract instruction, the C compiler has emitted multiple
subtract instructions.  In the case of the multiply, the compiler has chosen to
store the constant in a constant pool (labelled L5), and has planted a load
instruction to load the constant from the pool.  These are two different
instruction selection strategies, and a compiler may choose (as it has here) to
use a mixture of both.  The constant-pool is not a mechanism implemented within
the assembler, but instead is a one of a number of techniques available to the
compiler during instruction selection when generating code for which a single
assembly operation is not available.  The assembler is not aware of the
structure or semantics of the constant pool - it only sees a PC relative load
instruction.

Layering the compiler on top of an assembler in this fashion provides a number
of benefits.  For the compiler developer, layering the compiler on the
assembler separates the instruction selection from the minutiae of machine
instruction encoding.  For clients of the compiler providing a well defined
language for machine instruction generation is useful if the compiler provides
facilities to bypass the higher level language, and directly emit a specific
sequence of machine instructions (commonly though use of inline 'asm'
statements in C code, and in our JIT through direct use of 'm_assembler').

The assembler interface within the JIT is designed to closely mimic that of the
assembler layer in a traditional compiler, providing an interface largely made
up of the set of assembler mnemonics of the host architecture, with a
one-to-one mapping from calls to these functions, to machine instructions being
planted.  All instruction selection is performed within the MacroAssembler
layer.  The MacroAssembler is a very simple compiler, mapping from one
(generic) assembly like language to another (concrete, machine-specific)
assembly language.  We refer to it as a MacroAssembler since the capabilities
are presently very limited, simply remapping mnemonic names (e.g. addPtr ->
addq_rr), and expanding single MacroAssembler calls to multiple assembler
operations (facilities typically within the capabilities of traditional
macro-assembler languages).  However we certainly expect the sophistication of
the MacroAssembler layer to increase as necessary – and we tend to be
conservative in our naming, bear in mind that we initially labelled the entire
JIT as just a context-threaded-interpreter, a much simpler form of dynamic code
generation engine (and we still have the acronym 'cti' scattered through the
code as a reminder!).

### new\_object
Format: <code>new\_object dst(r)</code>

	  Constructs a new empty Object instance using the original
	  constructor, and puts the result in register dst.
 
### new\_array
Format: <code>new\_array dst(r) firstArg(r) argCount(n)</code>

	  Constructs a new Array instance using the original
	  constructor, and puts the result in register dst.
	  The array will contain argCount elements with values
	  taken from registers starting at register firstArg.
 
### new\_regexp
Format: <code>new\_regexp dst(r) regExp(re)</code>

	  Constructs a new RegExp instance using the original
	  constructor from regexp regExp, and puts the result in
	  register dst.
 
### mov
Format: <code>mov dst(r) src(r)</code>

	  Copies register src to register dst.
 
### eq
Format: <code>eq dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 and register src2 are equal,
	  as with the ECMAScript '==' operator, and puts the result
	  as a boolean in register dst.
 
### eq\_null
Format: <code>eq\_null dst(r) src(r)</code>

	  Checks whether register src is null, as with the ECMAScript '!='
	  operator, and puts the result as a boolean in register dst.
 
### neq
Format: <code>neq dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 and register src2 are not
	  equal, as with the ECMAScript '!=' operator, and puts the
	  result as a boolean in register dst.
 
### neq\_null
Format: <code>neq\_null dst(r) src(r)</code>

	  Checks whether register src is not null, as with the ECMAScript '!='
	  operator, and puts the result as a boolean in register dst.
 
### stricteq
Format: <code>stricteq dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 and register src2 are strictly
	  equal, as with the ECMAScript '===' operator, and puts the
	  result as a boolean in register dst.
 
### nstricteq
Format: <code>nstricteq dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 and register src2 are not
	  strictly equal, as with the ECMAScript '!==' operator, and
	  puts the result as a boolean in register dst.
 
### less
Format: <code>less dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 is less than register src2, as
	  with the ECMAScript '<' operator, and puts the result as
	  a boolean in register dst.
 
### lesseq
Format: <code>lesseq dst(r) src1(r) src2(r)</code>

	  Checks whether register src1 is less than or equal to
	  register src2, as with the ECMAScript '<=' operator, and
	  puts the result as a boolean in register dst.
 
### pre\_inc
Format: <code>pre\_inc srcDst(r)</code>

	  Converts register srcDst to number, adds one, and puts the result
	  back in register srcDst.
 
### pre\_dec
Format: <code>pre\_dec srcDst(r)</code>

	  Converts register srcDst to number, subtracts one, and puts the result
	  back in register srcDst.
 
### post\_inc
Format: <code>post\_inc dst(r) srcDst(r)</code>

	  Converts register srcDst to number. The number itself is
	  written to register dst, and the number plus one is written
	  back to register srcDst.
 
### post\_dec
Format: <code>post\_dec dst(r) srcDst(r)</code>

	  Converts register srcDst to number. The number itself is
	  written to register dst, and the number minus one is written
	  back to register srcDst.
 
### to\_jsnumber
Format: <code>to\_jsnumber dst(r) src(r)</code>

	  Converts register src to number, and puts the result
	  in register dst.
 
### negate
Format: <code>negate dst(r) src(r)</code>

	  Converts register src to number, negates it, and puts the
	  result in register dst.
 
### add
Format: <code>add dst(r) src1(r) src2(r)</code>

	  Adds register src1 and register src2, and puts the result
	  in register dst. (JS add may be string concatenation or
	  numeric add, depending on the types of the operands.)
 
### mul
Format: <code>mul dst(r) src1(r) src2(r)</code>

	  Multiplies register src1 and register src2 (converted to
	  numbers), and puts the product in register dst.
 
### div
Format: <code>div dst(r) dividend(r) divisor(r)</code>

	  Divides register dividend (converted to number) by the
	  register divisor (converted to number), and puts the
	  quotient in register dst.
 
### mod
Format: <code>mod dst(r) dividend(r) divisor(r)</code>

	  Divides register dividend (converted to number) by
	  register divisor (converted to number), and puts the
	  remainder in register dst.
 
### sub
Format: <code>sub dst(r) src1(r) src2(r)</code>

	  Subtracts register src2 (converted to number) from register
	  src1 (converted to number), and puts the difference in
	  register dst.
 
### lshift
Format: <code>lshift dst(r) val(r) shift(r)</code>

	  Performs left shift of register val (converted to int32) by
	  register shift (converted to uint32), and puts the result
	  in register dst.
 
### rshift
Format: <code>rshift dst(r) val(r) shift(r)</code>

	  Performs arithmetic right shift of register val (converted
	  to int32) by register shift (converted to
	  uint32), and puts the result in register dst.
 
### urshift
Format: <code>rshift dst(r) val(r) shift(r)</code>

	  Performs logical right shift of register val (converted
	  to uint32) by register shift (converted to
	  uint32), and puts the result in register dst.
 
### bitand
Format: <code>bitand dst(r) src1(r) src2(r)</code>

	  Computes bitwise AND of register src1 (converted to int32)
	  and register src2 (converted to int32), and puts the result
	  in register dst.
 
### bitxor
Format: <code>bitxor dst(r) src1(r) src2(r)</code>

	  Computes bitwise XOR of register src1 (converted to int32)
	  and register src2 (converted to int32), and puts the result
	  in register dst.
 
### bitor
Format: <code>bitor dst(r) src1(r) src2(r)</code>

	  Computes bitwise OR of register src1 (converted to int32)
	  and register src2 (converted to int32), and puts the
	  result in register dst.
 
### bitnot
Format: <code>bitnot dst(r) src(r)</code>

	  Computes bitwise NOT of register src1 (converted to int32),
	  and puts the result in register dst.
 
### not
Format: <code>not dst(r) src(r)</code>

	  Computes logical NOT of register src (converted to
	  boolean), and puts the result in register dst.
 
### instanceof
Format: <code>instanceof dst(r) value(r) constructor(r) constructorProto(r)</code>

	  Tests whether register value is an instance of register
	  constructor, and puts the boolean result in register
	  dst. Register constructorProto must contain the "prototype"
	  property (not the actual prototype) of the object in
	  register constructor. This lookup is separated so that
	  polymorphic inline caching can apply.
 
	  Raises an exception if register constructor is not an
	  object.
 
### typeof
Format: <code>typeof dst(r) src(r)</code>

	  Determines the type string for src according to ECMAScript
	  rules, and puts the result in register dst.
 
### is\_undefined
Format: <code>is\_undefined dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "undefined", and puts the result
	  in register dst.
 
### is\_boolean
Format: <code>is\_boolean dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "boolean", and puts the result
	  in register dst.
 
### is\_number
Format: <code>is\_number dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "number", and puts the result
	  in register dst.
 
### is\_string
Format: <code>is\_string dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "string", and puts the result
	  in register dst.
 
### is\_object
Format: <code>is\_object dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "object", and puts the result
	  in register dst.
 
### is\_function
Format: <code>is\_function dst(r) src(r)</code>

	  Determines whether the type string for src according to
	  the ECMAScript rules is "function", and puts the result
	  in register dst.
 
### in
Format: <code>in dst(r) property(r) base(r)</code>

	  Tests whether register base has a property named register
	  property, and puts the boolean result in register dst.
 
	  Raises an exception if register constructor is not an
	  object.
 
### resolve
Format: <code>resolve dst(r) property(id)</code>

	  Looks up the property named by identifier property in the
	  scope chain, and writes the resulting value to register
	  dst. If the property is not found, raises an exception.
 
### resolve\_skip
Format: <code>resolve\_skip dst(r) property(id) skip(n)</code>

	Looks up the property named by identifier property in the
	scope chain skipping the top 'skip' levels, and writes the resulting
	value to register dst. If the property is not found, raises an exception.
 
### resolve\_global
Format: <code>resolve\_skip dst(r) globalObject(c) property(id) structure(sID) offset(n)</code>
         
	  Performs a dynamic property lookup for the given property, on the provided
	  global object.  If structure matches the Structure of the global then perform
	  a fast lookup using the case offset, otherwise fall back to a full resolve and
	  cache the new structure and offset
 
### get\_global\_var
Format: <code>get\_global\_var dst(r) globalObject(c) index(n)</code>

	  Gets the global var at global slot index and places it in register dst.
 
### put\_global\_var
Format: <code>put\_global\_var globalObject(c) index(n) value(r)</code>
         
	  Puts value into global slot index.
 
### get\_scoped\_var
Format: <code>get\_scoped\_var dst(r) index(n) skip(n)</code>

	Loads the contents of the index-th local from the scope skip nodes from
	the top of the scope chain, and places it in register dst
 
### put\_scoped\_var
Format: <code>put\_scoped\_var index(n) skip(n) value(r)</code>

 
### resolve\_base
Format: <code>resolve\_base dst(r) property(id)</code>

	  Searches the scope chain for an object containing
	  identifier property, and if one is found, writes it to
	  register dst. If none is found, the outermost scope (which
	  will be the global object) is stored in register dst.
 
### resolve\_with\_base
Format: <code>resolve\_with\_base baseDst(r) propDst(r) property(id)</code>

	  Searches the scope chain for an object containing
	  identifier property, and if one is found, writes it to
	  register srcDst, and the retrieved property value to register
	  propDst. If the property is not found, raises an exception.
 
	  This is more efficient than doing resolve_base followed by
	  resolve, or resolve_base followed by get_by_id, as it
	  avoids duplicate hash lookups.
 
### resolve\_func
Format: <code>resolve\_func baseDst(r) funcDst(r) property(id)</code>

	  Searches the scope chain for an object containing
	  identifier property, and if one is found, writes the
	  appropriate object to use as "this" when calling its
	  properties to register baseDst; and the retrieved property
	  value to register propDst. If the property is not found,
	  raises an exception.
 
	  This differs from resolve_with_base, because the
	  global this value will be substituted for activations or
	  the global object, which is the right behavior for function
	  calls but not for other property lookup.
 
### get\_by\_id
Format: <code>get\_by\_id dst(r) base(r) property(id) structure(sID) nop(n) nop(n) nop(n)</code>

	  Generic property access: Gets the property named by identifier
	  property from the value base, and puts the result in register dst.
 
### get\_by\_id\_self
Format: <code>op\_get\_by\_id\_self dst(r) base(r) property(id) structure(sID) offset(n) nop(n) nop(n)</code>

	  Cached property access: Attempts to get a cached property from the
	  value base. If the cache misses, op_get_by_id_self reverts to
	  op_get_by_id.
 
### get\_by\_id\_proto
Format: <code>op\_get\_by\_id\_proto dst(r) base(r) property(id) structure(sID) prototypeStructure(sID) offset(n) nop(n)</code>

	  Cached property access: Attempts to get a cached property from the
	  value base's prototype. If the cache misses, op_get_by_id_proto
	  reverts to op_get_by_id.
 
### get\_by\_id\_chain
Format: <code>op\_get\_by\_id\_chain dst(r) base(r) property(id) structure(sID) structureChain(chain) count(n) offset(n)</code>

	  Cached property access: Attempts to get a cached property from the
	  value base's prototype chain. If the cache misses, op_get_by_id_chain
	  reverts to op_get_by_id.
 
### get\_by\_id\_generic
Format: <code>op\_get\_by\_id\_generic dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)</code>

	  Generic property access: Gets the property named by identifier
	  property from the value base, and puts the result in register dst.
 
### get\_array\_length
Format: <code>op\_get\_array\_length dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)</code>

	  Cached property access: Gets the length of the array in register base,
	  and puts the result in register dst. If register base does not hold
	  an array, op_get_array_length reverts to op_get_by_id.
 
### get\_string\_length
Format: <code>op\_get\_string\_length dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)</code>

	  Cached property access: Gets the length of the string in register base,
	  and puts the result in register dst. If register base does not hold
	  a string, op_get_string_length reverts to op_get_by_id.
 
### put\_by\_id
Format: <code>put\_by\_id base(r) property(id) value(r) nop(n) nop(n) nop(n) nop(n)</code>

	  Generic property access: Sets the property named by identifier
	  property, belonging to register base, to register value.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### put\_by\_id\_transition
Format: <code>op\_put\_by\_id\_transition base(r) property(id) value(r) oldStructure(sID) newStructure(sID) structureChain(chain) offset(n)</code>
         
	  Cached property access: Attempts to set a new property with a cached transition
	  property named by identifier property, belonging to register base,
	  to register value. If the cache misses, op_put_by_id_transition
	  reverts to op_put_by_id_generic.
	
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### put\_by\_id\_replace
Format: <code>op\_put\_by\_id\_replace base(r) property(id) value(r) structure(sID) offset(n) nop(n) nop(n)</code>

	  Cached property access: Attempts to set a pre-existing, cached
	  property named by identifier property, belonging to register base,
	  to register value. If the cache misses, op_put_by_id_replace
	  reverts to op_put_by_id.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### put\_by\_id\_generic
Format: <code>op\_put\_by\_id\_generic base(r) property(id) value(r) nop(n) nop(n) nop(n) nop(n)</code>

	  Generic property access: Sets the property named by identifier
	  property, belonging to register base, to register value.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### del\_by\_id
Format: <code>del\_by\_id dst(r) base(r) property(id)</code>

	  Converts register base to Object, deletes the property
	  named by identifier property from the object, and writes a
	  boolean indicating success (if true) or failure (if false)
	  to register dst.
 
### get\_by\_val
Format: <code>get\_by\_val dst(r) base(r) property(r)</code>

	  Converts register base to Object, gets the property named
	  by register property from the object, and puts the result
	  in register dst. property is nominally converted to string
	  but numbers are treated more efficiently.
 
### put\_by\_val
Format: <code>put\_by\_val base(r) property(r) value(r)</code>

	  Sets register value on register base as the property named
	  by register property. Base is converted to object
	  first. register property is nominally converted to string
	  but numbers are treated more efficiently.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### del\_by\_val
Format: <code>del\_by\_val dst(r) base(r) property(r)</code>

	  Converts register base to Object, deletes the property
	  named by register property from the object, and writes a
	  boolean indicating success (if true) or failure (if false)
	  to register dst.
 
### put\_by\_index
Format: <code>put\_by\_index base(r) property(n) value(r)</code>

	  Sets register value on register base as the property named
	  by the immediate number property. Base is converted to
	  object first.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
	  This opcode is mainly used to initialize array literals.
 
### loop
Format: <code>loop target(offset)</code>
         
	  Jumps unconditionally to offset target from the current
	  instruction.
 
	  Additionally this loop instruction may terminate JS execution is
	  the JS timeout is reached.
 
### jmp
Format: <code>jmp target(offset)</code>

	  Jumps unconditionally to offset target from the current
	  instruction.
 
### loop\_if\_true
Format: <code>loop\_if\_true cond(r) target(offset)</code>
         
	  Jumps to offset target from the current instruction, if and
	  only if register cond converts to boolean as true.
 
	  Additionally this loop instruction may terminate JS execution is
	  the JS timeout is reached.
 
### jtrue
Format: <code>jtrue cond(r) target(offset)</code>

	  Jumps to offset target from the current instruction, if and
	  only if register cond converts to boolean as true.
 
### jfalse
Format: <code>jfalse cond(r) target(offset)</code>

	  Jumps to offset target from the current instruction, if and
	  only if register cond converts to boolean as false.
 
### jeq\_null
Format: <code>jeq\_null src(r) target(offset)</code>

	  Jumps to offset target from the current instruction, if and
	  only if register src is null.
 
### jneq\_null
Format: <code>jneq\_null src(r) target(offset)</code>

	  Jumps to offset target from the current instruction, if and
	  only if register src is not null.
 
### jneq\_ptr
Format: <code>jneq\_ptr src(r) ptr(jsCell) target(offset)</code>
         
	  Jumps to offset target from the current instruction, if the value r is equal
	  to ptr, using pointer equality.
 
### loop\_if\_less
Format: <code>loop\_if\_less src1(r) src2(r) target(offset)</code>

	  Checks whether register src1 is less than register src2, as
	  with the ECMAScript '<' operator, and then jumps to offset
	  target from the current instruction, if and only if the 
	  result of the comparison is true.
 
	  Additionally this loop instruction may terminate JS execution is
	  the JS timeout is reached.
 
### loop\_if\_lesseq
Format: <code>loop\_if\_lesseq src1(r) src2(r) target(offset)</code>

	  Checks whether register src1 is less than or equal to register
	  src2, as with the ECMAScript '<=' operator, and then jumps to
	  offset target from the current instruction, if and only if the 
	  result of the comparison is true.
 
	  Additionally this loop instruction may terminate JS execution is
	  the JS timeout is reached.
 
### jnless
Format: <code>jnless src1(r) src2(r) target(offset)</code>

	  Checks whether register src1 is less than register src2, as
	  with the ECMAScript '<' operator, and then jumps to offset
	  target from the current instruction, if and only if the 
	  result of the comparison is false.
 
### jnlesseq
Format: <code>jnlesseq src1(r) src2(r) target(offset)</code>

	  Checks whether register src1 is less than or equal to
	  register src2, as with the ECMAScript '<=' operator,
	  and then jumps to offset target from the current instruction,
	  if and only if theresult of the comparison is false.
 
### switch\_imm
Format: <code>switch\_imm tableIndex(n) defaultOffset(offset) scrutinee(r)</code>

	  Performs a range checked switch on the scrutinee value, using
	  the tableIndex-th immediate switch jump table.  If the scrutinee value
	  is an immediate number in the range covered by the referenced jump
	  table, and the value at jumpTable[scrutinee value] is non-zero, then
	  that value is used as the jump offset, otherwise defaultOffset is used.
 
### switch\_char
Format: <code>switch\_char tableIndex(n) defaultOffset(offset) scrutinee(r)</code>

	  Performs a range checked switch on the scrutinee value, using
	  the tableIndex-th character switch jump table.  If the scrutinee value
	  is a single character string in the range covered by the referenced jump
	  table, and the value at jumpTable[scrutinee value] is non-zero, then
	  that value is used as the jump offset, otherwise defaultOffset is used.
 
### switch\_string
Format: <code>switch\_string tableIndex(n) defaultOffset(offset) scrutinee(r)</code>

	  Performs a sparse hashmap based switch on the value in the scrutinee
	  register, using the tableIndex-th string switch jump table.  If the 
	  scrutinee value is a string that exists as a key in the referenced 
	  jump table, then the value associated with the string is used as the 
	  jump offset, otherwise defaultOffset is used.
 
### new\_func
Format: <code>new\_func dst(r) func(f)</code>

	  Constructs a new Function instance from function func and
	  the current scope chain using the original Function
	  constructor, using the rules for function declarations, and
	  puts the result in register dst.
 
### new\_func\_exp
Format: <code>new\_func\_exp dst(r) func(f)</code>

	  Constructs a new Function instance from function func and
	  the current scope chain using the original Function
	  constructor, using the rules for function expressions, and
	  puts the result in register dst.
 
### call\_eval
Format: <code>call\_eval dst(r) func(r) argCount(n) registerOffset(n)</code>

	  Call a function named "eval" with no explicit "this" value
	  (which may therefore be the eval operator). If register
	  thisVal is the global object, and register func contains
	  that global object's original global eval function, then
	  perform the eval operator in local scope (interpreting
	  the argument registers as for the "call"
	  opcode). Otherwise, act exactly as the "call" opcode would.
 
### call
Format: <code>call dst(r) func(r) argCount(n) registerOffset(n)</code>

	  Perform a function call.
	  
	  registerOffset is the distance the callFrame pointer should move
	  before the VM initializes the new call frame's header.
	  
	  dst is where op_ret should store its result.
 
### call\_varargs
Format: <code>call\_varargs dst(r) func(r) argCountReg(r) baseRegisterOffset(n)</code>
         
	Perform a function call with a dynamic set of arguments.
	
	registerOffset is the distance the callFrame pointer should move
	before the VM initializes the new call frame's header, excluding
	space for arguments.
	
	dst is where op_ret should store its result.
 
### tear\_off\_activation
Format: <code>tear\_off\_activation activation(r)</code>

	  Copy all locals and parameters to new memory allocated on
	  the heap, and make the passed activation use this memory
	  in the future when looking up entries in the symbol table.
	  If there is an 'arguments' object, then it will also use
	  this memory for storing the named parameters, but not any
	  extra arguments.
 
	  This opcode should only be used immediately before op_ret.
 
### tear\_off\_arguments
Format: <code>tear\_off\_arguments</code>

	  Copy all arguments to new memory allocated on the heap,
	  and make the 'arguments' object use this memory in the
	  future when looking up named parameters, but not any
	  extra arguments. If an activation object exists for the
	  current function context, then the tear_off_activation
	  opcode should be used instead.
 
	  This opcode should only be used immediately before op_ret.
 
### ret
Format: <code>ret result(r)</code>
	 
	  Return register result as the return value of the current
	  function call, writing it into the caller's expected return
	  value register. In addition, unwind one call frame and
	  restore the scope chain, code block instruction pointer and
	  register base to those of the calling function.
 
### enter
Format: <code>enter</code>

	  Initializes local variables to undefined and fills constant
	  registers with their values. If the code block requires an
	  activation, enter_with_activation should be used instead.
 
	  This opcode should only be used at the beginning of a code
	  block.
 
### enter\_with\_activation
Format: <code>enter\_with\_activation dst(r)</code>

	  Initializes local variables to undefined, fills constant
	  registers with their values, creates an activation object,
	  and places the new activation both in dst and at the top
	  of the scope chain. If the code block does not require an
	  activation, enter should be used instead.
 
	  This opcode should only be used at the beginning of a code
	  block.
 
### convert\_this
Format: <code>convert\_this this(r)</code>

	  Takes the value in the 'this' register, converts it to a
	  value that is suitable for use as the 'this' value, and
	  stores it in the 'this' register. This opcode is emitted
	  to avoid doing the conversion in the caller unnecessarily.
 
	  This opcode should only be used at the beginning of a code
	  block.
 
### init\_arguments
Format: <code>create\_arguments</code>

	  Initialises the arguments object reference to null to ensure
	  we can correctly detect that we need to create it later (or
	  avoid creating it altogether).
 
	  This opcode should only be used at the beginning of a code
	  block.
 
### create\_arguments
Format: <code>create\_arguments</code>

	  Creates the 'arguments' object and places it in both the
	  'arguments' call frame slot and the local 'arguments'
	  register, if it has not already been initialised.
 
### construct
Format: <code>construct dst(r) func(r) argCount(n) registerOffset(n) proto(r) thisRegister(r)</code>

	  Invoke register "func" as a constructor. For JS
	  functions, the calling convention is exactly as for the
	  "call" opcode, except that the "this" value is a newly
	  created Object. For native constructors, no "this"
	  value is passed. In either case, the argCount and registerOffset
	  registers are interpreted as for the "call" opcode.
 
	  Register proto must contain the prototype property of
	  register func. This is to enable polymorphic inline
	  caching of this lookup.
 
### construct\_verify
Format: <code>construct\_verify dst(r) override(r)</code>

	  Verifies that register dst holds an object. If not, moves
	  the object in register override to register dst.
 
### push\_scope
Format: <code>push\_scope scope(r)</code>

	  Converts register scope to object, and pushes it onto the top
	  of the current scope chain.  The contents of the register scope
	  are replaced by the result of toObject conversion of the scope.
 
### pop\_scope
Format: <code>pop\_scope</code>

	  Removes the top item from the current scope chain.
 
### get\_pnames
Format: <code>get\_pnames dst(r) base(r)</code>

	  Creates a property name list for register base and puts it
	  in register dst. This is not a true JavaScript value, just
	  a synthetic value used to keep the iteration state in a
	  register.
 
### next\_pname
Format: <code>next\_pname dst(r) iter(r) target(offset)</code>

	  Tries to copies the next name from property name list in
	  register iter. If there are names left, then copies one to
	  register dst, and jumps to offset target. If there are none
	  left, invalidates the iterator and continues to the next
	  instruction.
 
### jmp\_scopes
Format: <code>jmp\_scopes count(n) target(offset)</code>

	  Removes the a number of items from the current scope chain
	  specified by immediate number count, then jumps to offset
	  target.
 
### push\_new\_scope
Format: <code>new\_scope dst(r) property(id) value(r)</code>
         
	  Constructs a new StaticScopeObject with property set to value.  That scope
	  object is then pushed onto the ScopeChain.  The scope object is then stored
	  in dst for GC.
 
### catch
Format: <code>catch ex(r)</code>

	  Retrieves the VM's current exception and puts it in register
	  ex. This is only valid after an exception has been raised,
	  and usually forms the beginning of an exception handler.
 
### throw
Format: <code>throw ex(r)</code>

	  Throws register ex as an exception. This involves three
	  steps: first, it is set as the current exception in the
	  VM's internal state, then the stack is unwound until an
	  exception handler or a native code boundary is found, and
	  then control resumes at the exception handler if any or
	  else the script returns control to the nearest native caller.
 
### new\_error
Format: <code>new\_error dst(r) type(n) message(k)</code>

	  Constructs a new Error instance using the original
	  constructor, using immediate number n as the type and
	  constant message as the message string. The result is
	  written to register dst.
 
### end
Format: <code>end result(r)</code>
	 
	  Return register result as the value of a global or eval
	  program. Return control to the calling native code.
 
### put\_getter
Format: <code>put\_getter base(r) property(id) function(r)</code>

	  Sets register function on register base as the getter named
	  by identifier property. Base and function are assumed to be
	  objects as this op should only be used for getters defined
	  in object literal form.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### put\_setter
Format: <code>put\_setter base(r) property(id) function(r)</code>

	  Sets register function on register base as the setter named
	  by identifier property. Base and function are assumed to be
	  objects as this op should only be used for setters defined
	  in object literal form.
 
	  Unlike many opcodes, this one does not write any output to
	  the register file.
 
### jsr
Format: <code>jsr retAddrDst(r) target(offset)</code>

	  Places the address of the next instruction into the retAddrDst
	  register and jumps to offset target from the current instruction.
 
### sret
Format: <code>sret retAddrSrc(r)</code>

	Jumps to the address stored in the retAddrSrc register. This
	differs from op_jmp because the target address is stored in a
	register, not as an immediate.
 
### debug
Format: <code>debug debugHookID(n) firstLine(n) lastLine(n)</code>

	Notifies the debugger of the current state of execution. This opcode
	is only generated while the debugger is attached.
 
### profile\_will\_call
Format: <code>op\_profile\_will\_call function(r)</code>

	Notifies the profiler of the beginning of a function call. This opcode
	is only generated if developer tools are enabled.
 
### profile\_did\_call
Format: <code>op\_profile\_did\_call function(r)</code>

	Notifies the profiler of the end of a function call. This opcode
	is only generated if developer tools are enabled.

### get\_by\_id\_self\_list
### get\_by\_id\_proto\_list
### load\_varargs
### strcat
### to\_primitive
### method\_check

[Changeset 44076](https://trac.webkit.org/changeset/44076)

op\_method\_check

Optimize method calls, by caching specific function values within the Structure.
The new opcode is used almost like an x86 opcode prefix byte to optimize op\_get\_by\_id,
where the property access is being used to read a function to be passed to op-call (i.e.
'foo.bar();'). This patch modifies the Structure class such that when a property is
put to an object for the first time we will check if the value is a function. If it is,
we will cache the function value on the Structure. A Structure in such a state guarantees
that not only does a property with the given identifier exist on the object, but also that
its value is unchanged. Upon any further attempt to put a property with the same identifier
(but a different value) to the object, it will transition back to a normal Structure (where
it will guarantee the presence but not the value of the property).

op_method_check makes use of the new information made available by the Structure, by
augmenting the functionality of op\_get\_by\_id. Upon generating a FunctionCallDotNode a
check will be emitted prior to the property access reading the function value, and the JIT
will generate an extra (initially unlinked but patchable) set of checks prior to the regular
JIT code for get\_by\_id. The new code will do inline structure and prototype structure check
(unlike a regular get_by_id, which can only handle 'self' accesses inline), and then performs
an immediate load of the function value, rather than using memory accesses to load the value
from the obejct's property storage array. If the method check fails it will revert, or if
the access is polymorphic, the op_get_by_id will continue to operate - and optimize itself -
just as any other regular op\_get\_by\_id would.

## Bytecode Examples

### For loop

Input:

	var i, s;
	s = 0;
	for (i=1; i < 11; i++) {
		s += i;
	}
	print(s);

Result:

	16 m_instructions; 196 bytes at 0xa19460; 1 parameter(s); 12 callee register(s)

	[   0] enter
	[   1] mov		 r-15, r1073741824                // Set r-15 to undefined
	[   4] mov		 r-16, r1073741824                // Set r-15 to undefined
	[   7] mov		 r0, r1073741824                  // Set r0 to undefined
	[  10] mov		 r-16, r1073741825                // Set r-16 to 0
	[  13] mov		 r0, r-16                         // Set r0 to 0 to handle the implied return value of global (and eval) code
	[  16] mov		 r-15, r1073741826                // Set r-15 to 0
	[  19] jmp		 11(->31)                         // Jump to [31]
	[  21] add		 r-16, r-16, r-15                 // r-16 = r-16 + r-15
	[  26] mov		 r0, r-16                         // Set r0 to r-16 to handle the implied return value of global (and eval) code
	[  29] pre_inc		 r-15                         // r-15 ++
	[  31] loop_if_less	 r-15, r1073741827, -13(->21) // if (r-15 < 11)
	[  35] resolve_func	 r2, r1, print(@id0)          // Set r2 to this, r1 to function object
	[  39] mov		 r3, r-16                         // Mystery
	[  42] call		 r0, r1, 2, 12                    // call dst(r) func(r) argCount(n) registerOffset(n)
	[  47] end		 r0

	Identifiers:
	  id0 = print

	Constants:
	   r0 = undefined
	   r1 = 0
	   r2 = 1
	   r3 = 11

	3 m_instructions; 32 bytes at 0xa19d10; 3 parameter(s); 1 callee register(s)

	[   0] enter
	[   1] sub		 r0, r-10, r-9
	[   6] ret		 r0

	55
	End: undefined

## Direct-threaded dispatch

From [David Mandelin\’s blog](http://blog.mozilla.com/dmandelin/2008/06/03/squirrelfish/)

Interpreters tend to spend a lot of time dispatching bytecode operations. Direct-threaded dispatch is a technique for efficient dispatch.

The obvious way to write a bytecode interpreter is with a switch statement inside a loop:

    void run(Bytecode *ip) {
    for (;;) {
    switch (*ip++) {
    case OP_ADD: …
    case OP_JUMP: …

Each iteration runs one bytecode instruction. Each case of the switch handles one instruction type. It really doesn’t look like there’s any room for improvement here unless you look at the assembly code generated for the switch dispatch (from a tiny test interpreter I wrote today, comments added by me):

    # ip is in %edx
    # Check that switch expression (%edx) is in table range
    cmpl    $9, (%edx)
    leal    4(%edx), %ecx
    ja    L26
    # Look up case address offset for (%edx) in table (L37)
    movl    (%edx), %eax
    movl    L37-”L00000000006$pb”(%ebx,%eax,4), %eax
    # Add base address to offset
    addl    %ebx, %eax
    # Indirect jump to computed address
    jmp    *%eax

The basic idea is to keep a table of relative offsets to the cases, and then jump using that offset. Because the switch expression could evaluate to anything, the compiler must first generate a range check, so that if the switch expression doesn’t map to any case, the program leaves the switch instead of crashing unpredictably.

But in reality the range check is useless, because the interpreter can control what bytecodes actually appear, so this is 3 wasted instructions. Also, the lookup and base+offset address computation seems kind of clunky. I’d prefer dispatch code something like this:

    jmp    *%edx

This is direct threading. In principle, the idea is simple: the instruction code (e.g., OP_ADD) is the address of the case target code. (In the basic design, instruction codes are integers.) Then, this jump is all you need for dispatch.

Coding up direct threading is weird; normal C compilers don’t know how to do it. But it can be done with GCC’s computed goto extension (see the paper on direct threading from the SquirrelFish announcement). See also my tiny interpreter.

I believe TT and Spidermonkey use an intermediate design called indirect threading, which gets most of the speedup of direct threading, but allows integer opcodes. The opcode is an index into a table of case target addresses. So the dispatch code has to look up the case target, then jump, something like:

    leal   TABLE(%edx,4), %eax
    jmp   *%eax

Not too bad. I have no idea how significant the difference between direct and indirect threading is in practice, but even a few percent speedup would be great.
